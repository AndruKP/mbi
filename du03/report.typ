#import "@preview/lovelace:0.3.0": *

#set document(title: [
  Homework 3 for computer scientists \ Report
])


#set page(
  paper: "a4",
  numbering: "1",
  // columns: 2,
)

#set par(justify: true)
#set text(
  size: 12pt,
)

#show title: set text(size: 17pt)
#show title: set align(center)
#show title: set block(below: 1.2em)

#show link: set text(fill: blue)
#show ref:  set text(fill: blue)

#place(
  top + center,
  float: true,
  scope: "parent",
  clearance: 2em,
)[
  #title()

  #grid(
    columns: (1fr),
    align(center)[
      *Denys Andrukhovskyi*, 3BIN \
      #link("mailto:andrukhovskyi1@uniba.sk")[andrukhovskyi1\@uniba.sk]
    ]
  )

]


= Task 1: RNA structure and dynamic programming

== Subtask a)
Let $x = x_1 x_2 dots x_n$.
We start with defining recurence. 
Let $A[i,j]$ be the highest possible number of base pairs in a nested-only secondary structur
of substring $x_i x_(i+1) dots x_j$. Note that we use 1-based index.
Then:
$
  A[i,j] = cases(
    0 "if" i >= j,
    0 "if" i + 1 =j,
    max(A[i, j-1], A[i+1, j], c(x_(i),x_(j)) + A[i+1, j-1]) "otherwise"
    ,
  )
$
where $ c(x_i,x_j)= cases(1 "if bases are complementary", 0 "otherwise") $.
The meaning of this recurence is that: 
- for $i >= j$ we have empty substring of $x$, so the number of base pairs is zero;
- every substring of $x$ of length have 0 base pairs;
- for every substring $x_i x_(i+1) dots x_j$ of length at least 2 we check three cases:
  - $x_i$ isn't paired, then we count number of base pairs for substring $x_(i+1) dots x_j$, this is precisely $A[i+1,j]$;
  - $x_j$ isn't paired, then we count number of base pairs for substring $x_(i) dots x_(j-1)$, this is precisely $A[i,j-j]$;
  - #[$x_i$ and $x_j$ can be paired, then we pair them and count pairs in substring $x_(i+1) dots x_(j-1)$,
  this is precisely $A[i+1,j-1]$.
  Note that in this case $c(x_i,x_j)$ check if $x_i$ and $x_j$ indeed form a pair,
  only in the positive case we add $1$.]

Then the answer is of course in $A[1,n]$.

Note that this recurence is inspired by Nussinov algorithm,
but we take a look only at "extreme cases" where we divide substring into one-characted substring
and the rest of substring, because we don't want for structures like $..(..)..(..)..$ to appear,
which is exactly what happen if we divide substring into 2 smaller substring of length at least 2
in Nussinov algorithm.

== Computing the table

We can just augment Nussinov algorithm to calculate the values of the DP-table $A$.
#let length = $mono(l e n g t h)$
#pseudocode-list[
  + $A = [[0] dot n] dot n$
  + *for each* $length = 2, dots, n$  *do*
    + #line-label(<inner_loop>)*for each* $i = 1, dots, n - length + 1$  *do*
      + $j <- i + length - 1$
      + $A <- max(
        A[i+1,j], 
        A[i,j-1],
        c(x[i],x[j]) + A[i+1,j-1]
      )$
  + *end*
]
Function $c(b_1,b_2)$ can be defined trivially using one $mono("if")$. 

Complexity of this algorithm is $O(n^2)$, because for every of $n$ iterations
of the first loop we do $O(n)$ iterations at @inner_loop.
If we assume good implementation of a DP-table,
then read/write is $O(1)$, as well as a complexity of the function $c$.
$O(n dot O(n dot O(1))) = O(n^2)$


== Subtask b)
So, we need to define $G=(N,T,P,sigma)$, where $N$ is an alphabet of nonterminals, $T={A,C,G,U}$ is an alphabet of terminals, $sigma$ is a starting nonterminal and $P$ is a set of rules.

We take $N = {sigma}$ and $ P = {
  sigma -> A sigma U | U sigma A | C sigma G | G sigma C, \ 
  sigma -> A sigma | C sigma | G sigma | U sigma, \
  sigma -> sigma A | sigma C | sigma G | sigma U, \
  sigma -> epsilon
}. $

We claim that this grammar generates precisely what we need,
because corresponding CFG $G'=({sigma'}, {[,],.}, P, sigma')$, where 
$
  P = {
    sigma' -> [sigma'], .sigma', sigma'., epsilon
  }
$
generates precisely all nested-only expressions:
- every next pair of brackets is inside the previous one, because the only rule that generates brackets is $sigma -> [sigma']$, so every generated word represents some nested-only structure.
- all expressions of nested-only structure can be generated by $G'$, which one can show easily by induction on length of word.


== Subtask c)

We proceed with modifying recurences, adding new DP-table $B$. 
Let $A$ be the table for the highest number of supported base pairs within some substring
and $B$ be the table for the highest "number" of supported base pairs within some substring where both ends of that substring are paired.
Precisely, let:

$
  A[i,j] = cases(0 "if" i + 1 <= j,
                max(A[i+1, j], A[i,j-1], c(x_i,x_j) + B[i+1,j-1]) // the last can be B[i,j]
  )
$
and 
$
  B[i,j] = cases( -1 "if" i + 1 <= j,
                  -1 "if" c(x_i,x_j)=0,
                  max(1 + B[i+1, i-1], A[i+1, j-1]) "otherwise",
  )
$

The meaning for matrix $A$:
- base case is calculated cases in the same way,
- #[because we are counting supported base pairs, the third possibility is that
  $x_i$ and $x_j$ are paired and so is $x_(i-1), x_(j+1)$.
  This in needed because we count pair $x_i, x_j$ as supported, and the pair $x_(i-1), x_(j+1)$ is the supporter.
  Therefore we add $c(x_i,x_j)$ with $B[i+1,j-1]$].

For matrix $B$:
- trivial cases are $-1$, which means and pair $x_i,x_j$ isn't properly defined (e.g $i=j$) or isn't a pair (e.g.$x_i=A=x_j$).
- for non-trivial cases we have that $x_i$ and $x_j$ are forming a pair. Then:
  - If there is a supporter of $x_i, x_j$, we can add $1$ to the value of $B[i+1,j-1]$, which is the value of number of pairs supposing $x_(i+1),x_(j-1)$ is a valid supporter.
    - If $x_(i+1),x_(j-1)$ isn't a valid supporter, then $1+B[i+1,j-1]=1+-1=0$. This value won't be greater than $A[i+1,j-1]$, because $forall i,j: A[i,j] >= 0$.
  - If there is no supporter for $x_i, x_j$, we just use the value of $A[i+1,j-1]$, because $x_i,x_j$ is a valid pair, but not a supported pair (Therefore we do not add $1$, but we do not set the value to be $-1$); and in $A[i,j]$ we have a number of supported pairs for substring $x_(i+1) dots x_j$.

    


// i.e. $B$ is a matrix which represents the number of pairs

= Task 2: Bioinformatics tools and databases

#lorem(100)
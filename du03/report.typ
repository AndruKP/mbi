#import "@preview/lovelace:0.3.0": *

#set document(title: [
  Homework 3 for computer scientists \ Report
])


#set page(
  paper: "a4",
  numbering: "1",
  // columns: 2,
)

#set par(justify: true)
#set text(
  size: 12pt,
)

#show title: set text(size: 17pt)
#show title: set align(center)
#show title: set block(below: 1.2em)

#show link: set text(fill: blue)
#show ref:  set text(fill: blue)

#place(
  top + center,
  float: true,
  scope: "parent",
  clearance: 2em,
)[
  #title()

  #grid(
    columns: (1fr),
    align(center)[
      *Denys Andrukhovskyi*, 3BIN \
      #link("mailto:andrukhovskyi1@uniba.sk")[andrukhovskyi1\@uniba.sk]
    ]
  )

]


= Task 1: RNA structure and dynamic programming

== Subtask a)
Let $x = x_1 x_2 dots x_n$.
We start with defining recurence. 
Let $A[i,j]$ be the highest possible number of base pairs in a nested-only secondary structure
of substring $x_i x_(i+1) dots x_j$. Note that we use 1-based index.
Then:
$
  A[i,j] = cases(
    0 "if" i >= j,
    0 "if" i + 1 =j,
    max(A[i, j-1], A[i+1, j], c(x_(i),x_(j)) + A[i+1, j-1]) "otherwise"
    ,
  )
$
where $ c(x_i,x_j)= cases(1 "if bases are complementary,", 0 "otherwise.") $
The meaning of this recurence is that: 
- for $i >= j$ we have empty substring of $x$, so the number of base pairs is zero;
- every substring of $x$ of length 1 have 0 base pairs;
- for every substring $x_i x_(i+1) dots x_j$ of length at least 2 we check three cases:
  - $x_i$ isn't paired, then we count number of base pairs for substring $x_(i+1) dots x_j$, this is precisely $A[i+1,j]$;
  - $x_j$ isn't paired, then we count number of base pairs for substring $x_(i) dots x_(j-1)$, this is precisely $A[i,j-j]$;
  - #[$x_i$ and $x_j$ can be paired, then we pair them and count pairs in substring $x_(i+1) dots x_(j-1)$,
  this is precisely $A[i+1,j-1]$.
  Note that in this case $c(x_i,x_j)$ check if $x_i$ and $x_j$ indeed form a pair,
  only in the positive case we add $1$.]

Then the answer is of course in $A[1,n]$.

Note that this recurence is inspired by Nussinov algorithm,
but we take a look only at "extreme cases" where we divide substring into one-character substring
and the rest of substring, because we don't want for structures like $..(..)..(..)..$ to appear,
which is exactly what happen if we divide substring into 2 smaller substring of length at least 2
in Nussinov algorithm.

== Computing the table

We can just augment Nussinov algorithm to calculate the values of the DP-table $A$.
#let length = $mono(l e n g t h)$

#block(breakable: false)[
#pseudocode-list[
  + $A = [[0] dot n] dot n$
  + *for each* $length = 2, dots, n$  *do*
    + #line-label(<inner_loop>)*for each* $i = 1, dots, n - length + 1$  *do*
      + $j <- i + length - 1$
      + $A <- max(
        A[i+1,j], 
        A[i,j-1],
        c(x[i],x[j]) + A[i+1,j-1]
      )$
    + *end*
  + *end*
]]
Function $c(b_1,b_2)$ can be defined trivially using one $mono("if")$. 

Complexity of this algorithm is $O(n^2)$, because for every of $n$ iterations
of the first loop we do $O(n)$ iterations at @inner_loop.
If we assume good implementation of a DP-table,
then read/write is $O(1)$, as well as a complexity of the function $c$.
$O(n dot O(n dot O(1))) = O(n^2)$


== Subtask b)
So, we need to define $G=(N,T,P,sigma)$, where $N$ is an alphabet of nonterminals, $T={A,C,G,U}$ is an alphabet of terminals, $sigma$ is a starting nonterminal and $P$ is a set of rules.

We take $N = {sigma}$ and $ P = {
  sigma -> A sigma U | U sigma A | C sigma G | G sigma C, \ 
  sigma -> A sigma | C sigma | G sigma | U sigma, \
  sigma -> sigma A | sigma C | sigma G | sigma U, \
  sigma -> epsilon
}. $

We claim that this grammar generates precisely what we need,
because corresponding CFG $G'=({sigma'}, {[,],.}, P, sigma')$, where 
$
  P = {
    sigma' -> [sigma'], .sigma', sigma'., epsilon
  }
$
generates precisely all nested-only expressions:
- every next pair of brackets is inside the previous one, because the only rule that generates brackets is $sigma' -> [sigma']$, so every generated word represents some nested-only structure.
- all expressions of nested-only structure can be generated by $G'$, which one can show easily by induction on the length of the word.


== Subtask c)

We proceed with modifying recurences, adding new DP-table $B$. 
Let $A$ be the table for the highest number of supported base pairs within some substring
and $B$ be the table for the highest "number" of supported base pairs within some substring where both ends of that substring are paired.
Precisely, let:

$
  A[i,j] = cases(0 "if" i + 1 >= j,
                max(A[i+1, j], A[i,j-1], c(x_i,x_j) + B[i+1,j-1]) // the last can be B[i,j]
  )
$
and 
$
  B[i,j] = cases( -infinity "if" i + 1 >= j,
                  -infinity "if" c(x_i,x_j)=0,
                  max(1 + B[i+1, i-1], A[i+1, j-1]) "otherwise",
  )
$

The meaning for matrix $A$:
- base case is calculated cases in the same way,
- #[because we are counting _supported_ base pairs, the third possibility is that
  $x_i$ and $x_j$ are paired and so is $x_(i-1), x_(j+1)$.
  This is needed because we count pair $x_i, x_j$ as supported, and the pair $x_(i-1), x_(j+1)$ is the supporter.
  Therefore we add $c(x_i,x_j)$ with $B[i+1,j-1]$].
  - If $x_(i+1),x_(j-1)$ don't form a pair, the value is $c(x_i,x_j)+(-infinity)=-infinity$, and it won't affect the value of the maximum, which is exactly what we want.

For matrix $B$:
- trivial cases are $-infinity$, which means and pair $x_i,x_j$ isn't properly defined (e.g $i=j$) or isn't a pair (e.g.$x_i=A=x_j$).
- for non-trivial cases we have that $x_i$ and $x_j$ are forming a pair. Then:
  - If there is a supporter of $x_i, x_j$, we can add $1$ to the value of $B[i+1,j-1]$, which is the value of number of pairs supposing $x_(i+1),x_(j-1)$ is a valid supporter.
    - #[If $x_(i+1),x_(j-1)$ isn't a valid supporter, then $1+B[i+1,j-1]=1+-infinity=-infinity$.
    This value won't be greater than $A[i+1,j-1]$, because $forall i,j: A[i,j] >= 0$; so, once more, it won't affect the maximum.]
  - If there is no supporter for $x_i, x_j$, we just use the value of $A[i+1,j-1]$, because $x_i,x_j$ is a valid pair, but not a supported pair (therefore we do not add $1$, but we do not set the value to be $-infinity$); and in $A[i+1,j-1]$ we have a number of supported pairs a for substring $x_(i+1) dots x_(j-1)$.

Then the value we were asked for is in $A[1,n]$. 
Calculations once more can be done using modified Nussinov algorithm, where we iterate through the entries of matrices in the way "from main diagonal to the right upper corner".
There won't be any complications with calculating these two matrices, as both matrices depend only on values with smaller difference $j-i$.

Once more, complexity is $O(n^2)$, because we have 2 loops, one inside the other one, and one iteration is constant.

#block(breakable: false)[
#pseudocode-list[
  + $A = [[0] dot n] dot n$
  + $B = [[0] dot n] dot n$
  + *for each* $i=1, dots, n$ *do*
    + *for each* $j=1, dots, n$ *do*
      + *if* $i+1 >= j$
        + $B[i,j] <- -infinity$
      + *end*
    + *end*
  + *end*
  + *for each* $length = 2, dots, n$  *do*
    + #line-label(<inner_loop_c>)*for each* $i = 1, dots, n - length + 1$  *do*
      + $j <- i + length - 1$
      + $A <- max(
        A[i+1,j], 
        A[i,j-1],
        c(x[i],x[j]) + B[i+1,j-1]
      )$
      + *if* $c(x[i],x[j])=0$
        + $B[i,j] <- -infinity$
      + *else*
        + $B[i,j] <- max(A[i+1, j-1], 1+B[i+1,j-1])$
      + *end*
    + *end*
  + *end*
]]

// i.e. $B$ is a matrix which represents the number of pairs

= Task 2: Bioinformatics tools and databases

== Subtask a) 

We get the entry `Acinetobacter lwoffii strain H7 chromosome, complete genome`.
Let's list some facts about entry:
- Scientific name of the organism is "Acinetobacter lwoffii"
- Percentage of identity is 95.13%.
- E-value is 0.0.

== Subtask b)

#let orf1 = read("orf1.fasta")
#let orf3 = read("orf3.fasta")

We insert the values of `orf1` and `orf3`.

#text(font: "DejaVu Sans Mono")[#orf1]

#text(font: "DejaVu Sans Mono")[#orf3]

== Subtask c)

For `orf1` there are four conserved domains, which can be seen at table @t1.

#set table(
  fill: (x, y) =>
    if x == 0 or y == 0 {
      gray.lighten(40%)
    },
  align: right,
)
#show figure: set block(breakable: true) 
#figure(
  table( 
  columns: (auto, auto, auto, auto, auto),
  inset: 10pt,
  align: horizon,
  table.header(
    [*Name*], [Accession], [Description], [*Interval*], [*E-value*]
  ),
  [2-oxoacid_dh],  [pfam00198], [2-oxoacid dehydrogenases acyltransferase (catalytic domain)], [343-554], [$4.85 times 10^(-82)$],
  [Biotin_lipoyl], [pfam00364], [Biotin-requiring enzyme],                                     [129-200], [$6.94 times 10^(-18)$],
  [Biotin_lipoyl], [pfam00364], [Biotin-requiring enzyme],                                     [17-88],   [$8.17 times 10^(-16)$],
  [E3_binding],    [pfam02817], [e3 binding domain],                                           [257-292], [$4.09 times 10^(-12)$],
),
caption: [Domains that found in Pfam for `orf1`]
) <t1>

For `orf3` there are no conserved domains.
Therefore we can conclude that `orf1` has a greater chance of being an evolutionary conserved protein.

== Subtask d)

We start with `orf1` as a more interesting example. 
From the "Predicted LDDT" graph one can see 4 plateaus of high quality (as said in the part *How confident should I be in a prediction?*), as the quality isn't lower that 70.
We can also see this 4 regions on the graph of PAE, where coordinates of plateaus and squares with lower PAE value are essentially the same.
Note that these coordinates fit very well with coordinates of four domains in @t1 (with partial exception of 2-oxoacid dehydrogenases acyltransferase domain, which has start at 343, while the fourth plateau starts around 310;
this error though can be seen in the PAE graph, where region $(300-550)times (310-350)$ has a slightly higher level of errors compared to the rest of the domain).

Now let's look at the graphs of `orf3`. We see a different story here.
Rather a smaller part of the graph has scores above 70, so we cannot treat most of the predicted structure as a meaningful one. 
There is only one bump of the length 50, which we could treat as possible domain (on the image this part is a helix).
Also, as one would expect, on the graph of PAE there is only one block of smaller error (which once more corresponds to the bump in the quality, i.e. the same helix). _Therefore, `orf1`, as one would expect, is in general more reliable_.